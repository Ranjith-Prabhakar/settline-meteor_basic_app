*.basically meteor has a well folder structure
*.codes written in client folder is the only code will be available to the browser
*.so as the codes written in the folder server will be accessible only in the server side 
*.codes written out of these folders will be shared by both still there are folders those couldn't be accessible by either client or server
*.assets and styles written in the public folder is only accessible by client side codes and also we dont want to put the public directory
  while using the path
*.assets and codes in the privet repository is specifically for server
*.meteor follows a lazy evaluation as well as eager/greedy evaluation 
*.for lazy evalution it follows a folder structure no modules inside of the import folder will be bundled but send to when they needed 
 if any other files imports any of the functions/objects/variables from this modules only they will
 send to 
*.we can't import any data from any modules which are written inside the server folder to any modules 
  which is written inside the client folder VICE VERSA 
*.even if there folders having names like server or clinent inside the import the rule will be applied 
  on them too
*. in the server side code meteor follows a syncronous style using  only single thread, which is a little diff than the usuall
   async callback/async/await pattern but behind the hood using fiber meteor manages the concurrency very well
*.client/compatibility
    "This folder is for compatibility with JavaScript libraries that rely on variables declared with var at the top level being exported as globals."
     Older JavaScript libraries, particularly those written before ES6, often rely on global variables. This means they expect variables declared with var at the top level to be accessible across the entire application.
     In modern JavaScript, files are usually scoped (meaning variables in one file don’t automatically leak to other files), but these older libraries don’t follow this pattern, and they expect their variables to be globally accessible.   
     
*.meteor introduced a new network communication protocol which is called Distributed Data Protocol( DDP ) this is the underlying mechanism of
  meteors real time working . because this use websocket under the hood , also if websocket connection isn't alive they will automatically
  use the http polling

*.once a client establish a connection with the server using this DDP protocol they become syncronous and client could make a 
  subscription once it happend the server will make publications. once the server send data using the publishing method that will
  comes to the client and store in the miniMongo which is the local memory of the browser/moblie so that client could 
  operate various actions we could do with the mongoDb but miniMongo is not exactly as mongodb. anyway if the client make any updates on 
  miniMongo then it will reflect to the server and will update the database also. it is all possible because of the DDP and meteor reactivity

  creating a miniMongo = const Tasks = new Mongo.Collection('tasks');
  Insert a document:Tasks.insert({ name: 'Do laundry', completed: false });
  Query for documents:const task = Tasks.findOne({ name: 'Do laundry' });
  Update a document:Tasks.update(task._id, { $set: { completed: true } });

  These operations will be mirrored on the server-side MongoDB instance.

  Latency Compensation:
      Latency compensation is one of the most powerful features of Minimongo. When the client performs an operation (like inserting or updating a document), Minimongo immediately reflects the change on the client, even before the server has confirmed it.
      This allows the app to feel fast and responsive, as the user doesn’t have to wait for round-trip communication with the server to see the result of their actions.
      If the server rejects the operation (e.g., due to a validation error), Minimongo will revert the change.
  Offline Support:
     Since Minimongo stores data in memory on the client, it offers limited offline support. When a client is temporarily disconnected, it can still interact with the data stored in Minimongo.
     Once the connection is re-established, Minimongo will sync with the server, sending any local changes to the server and updating the client’s data with any changes that happened on the server during the disconnection.
*.Sharing Code: You can reuse code between multiple apps by using npm or Atmosphere packages for public modules, or git submodules/symbolic links for private/shared code.
  Sharing Data: Apps can share data by pointing to the same MongoDB instance or interacting via an API (using DDP for server-server communication).
  Sharing Accounts: Users can be authenticated across multiple servers by sharing the login token between apps, allowing seamless movement between different parts of the system without needing to log in again.
  This structure is somewhat aligned with microservices architecture, as you are splitting functionalities (like admin panels or worker processes) into separate services/apps, each potentially with its own scaling and deployment strategy.
*.When designing a data schema in Meteor, there are certain aspects of its data loading system and communication protocol (DDP) that influence how you should structure your data, especially when dealing with documents that have subfields that change frequently.
  Key Concepts:
  Meteor's DDP and Top-Level Fields:
  
  DDP (Distributed Data Protocol) is how Meteor communicates data between the server and client.
  DDP works at the top level of a document, meaning any change to a subfield within a document results in the entire top-level field being resent over the network.
  For example, if you have a document that includes an array of sub-documents (like a list of todos), changing one todo requires DDP to resend the entire array of todos, even if only one todo has changed.
  Inefficiency with Large and Complex Subfields:
  
  In MongoDB, you might design a document that has complex fields (such as an array of objects), but in Meteor, if any part of that array changes, the entire array has to be resent.
  This can lead to unnecessary network traffic if you're frequently modifying subfields.
*.After subscribing, data is stored in the client’s local Minimongo cache. To display it in the UI, you need to query the collection.  

*When you subscribe to data in Meteor, the server sends specific documents to the client, which are stored in the client-side Minimongo database. The client can then query this local collection to use the data in the UI.
 but Different subscriptions push data to the same collection: In Meteor, multiple subscriptions can send data to the same local collection on the client. For example, if you have two different subscriptions to the Lists collection, one for public lists and one for private lists, both of these will send documents into the same Lists collection on the client.
 Querying all data without filters can lead to unexpected results: If you use a general query like Lists.find() (which fetches all documents in the Lists collection), you might accidentally get both public and private lists, even though you may only want one type of list in a particular UI component. This is because Lists.find() doesn’t apply any filters, and it pulls all the documents that have been subscribed to, regardless of which subscription they came from.
 always query the client-side Minimongo collection with the same filter you used when subscribing to the data. This ensures that you only get the specific subset of data that the server sent based on your subscription, preventing any unexpected or mixed results.